#+TITLE: ArenaController
#+AUTHOR: Peter Polidoro
#+EMAIL: peter@polidoro.io

* Library Information
- Name: ArenaController
- Description: Arduino library for communicating with the Reiser Lab Modular LED Display panels.
- Version: 4.0.0
- Panel Version: G4 v1.9
- Release Date: 2025-09-18
- Creation Date: 2023-08-16
- License: GPLv3
- URL: https://github.com/janelia-arduino/ArenaController
- Author: Peter Polidoro
- Email: peter@polidoro.io
- Copyright: 2025 Howard Hughes Medical Institute
- References:
  - [[https://github.com/janelia-python/arena_interface_python][Arena Python Interface]]
  - [[https://reiserlab.github.io/Modular-LED-Display/][Modular LED Displays]]
  - [[https://github.com/floesche/LED-Display_G4_Hardware_Arena][LED-Display_G4_Hardware_Arena]]
  - [[https://github.com/leburnett/G4_Display_Tools][G4_Display_Tools]]
  - [[https://www.pjrc.com/store/teensy41.html][Teensy 4.1]]
  - [[https://www.pjrc.com/store/ethernet_kit.html][Teensy 4.1 Ethernet Kit]]
  - [[https://github.com/QuantumLeaps/qp-arduino][qp-arduino]]
  - [[https://mongoose.ws/][Embedded Mongoose web server]]
  - [[https://www.adafruit.com/product/4470][Analog Output Board]]
  - [[https://www.adafruit.com/product/1083][Analog Input Board]]

* Modular LED Display

#+html: <img src="./documentation/images/arena.png" width="1200px">

Abstract from https://doi.org/10.1101/2022.08.02.502550 :

"Visual stimulation of animals in the laboratory is a powerful technique for
studying sensory control of complex behaviors.

Since commercial displays are optimized for human vision, we established a novel
display system based on custom-built modular LED panels that provides
millisecond refresh, precise synchronization, customizable color combinations,
and varied display configurations.

This system simplifies challenging experiments.

With variants of this display, we probed the speed limits of motion vision and
examined the role of color vision in behavioral experiments with tethered flying
Drosophila.

Using 2-photon calcium imaging, we comprehensively mapped the tuning of visual
projection neurons across the flyâ€™s field of view.

Finally, using real-time behavior analysis, we developed low-latency interactive
virtual environments and found that flying flies can independently control their
navigation along two dimensions.

This display system uniquely addresses most technical challenges of small animal
vision experiments and is thoroughly documented for replicability."

** System Components

*** Quarter Panel

A quarter panel is a set of LED pixels arranged in rows and columns.

#+html: <img src="./documentation/images/quarter_panel.png" width="96px">

*** Panel

A panel is a set of quarter panels arranged in rows and columns.

#+html: <img src="./documentation/images/panel.png" width="192px">

*** Region

A region is a set of panels arranged in rows and columns with a common communication interface.

#+html: <img src="./documentation/images/region.png" width="607px">

*** Display

An display is a set of regions arranged in rows and columns.

#+html: <img src="./documentation/images/display.png" width="1214px">

** Display Messages

*** Quarter Panel

**** Pixels

Pixel numbering for each pixel in a quarter panel:

#+html: <img src="./documentation/images/quarter_panel_pixels.png" width="1200px">

**** Grayscale

In grayscale mode, each LED can be one of sixteen brightness levels.

#+html: <img src="./documentation/images/grayscale.png" width="420px">

#+html: <img src="./documentation/images/quarter_panel_grayscale.png" width="1200px">

**** Binary

In binary mode, each LED can be one of two brightness levels, on or off.

#+html: <img src="./documentation/images/binary.png" width="420px">

#+html: <img src="./documentation/images/quarter_panel_binary.png" width="1200px">

*** Panel

**** Quarter Panels in Panel

Quarter panel numbering for each quarter panel in a panel plus pixel numbering for select pixels in a panel:

#+html: <img src="./documentation/images/panel_quarter_panels.png" width="1200px">

*** Region

**** Regions in Display

Region numbering for each region in an display:

#+html: <img src="./documentation/images/display_regions.png" width="1200px">

**** Panels in Region

Panel numbering for each panel in an region:

#+html: <img src="./documentation/images/region_panels.png" width="600px">

*** Display

**** Panels in Display

Panel update order for each panel in an display:

***** Synchronous

#+html: <img src="./documentation/images/display_panels_synchronous.png" width="1200px">

***** Asynchronous

#+html: <img src="./documentation/images/display_panels_asynchronous.png" width="1200px">

** Firmware

*** Active Objects

| name                     | priority | event-queue-count | state-machines                   |
|--------------------------+----------+-------------------+----------------------------------|
| Watchdog                 |        1 |                 2 | Watchdog                         |
| SerialCommandInterface   |        2 |                10 | SerialCommandInterface           |
| EthernetCommandInterface |        3 |                10 | EthernetCommandInterface         |
| Pattern                  |        4 |                20 | Pattern, Card                    |
| Arena                    |        5 |                20 | Arena, AnalogOutput, AnalogInput |
| Display                  |        6 |                20 | Display                          |
| Frame                    |        7 |                20 | Frame                            |

*** State Diagrams

**** Watchdog

#+BEGIN_SRC plantuml :file ./documentation/images/state-diagram-watchdog.png :results none
@startuml
!theme spacelab
skinparam backgroundColor #808080
state Feeding {
  Feeding : entry / armWatchdogTimer()
  Feeding : exit / disarmWatchdogTimer()
  state Initialized {
    Initialized : on WATCHDOG_TIMEOUT / feedWatchdog()
  }
  [*] --> Initialized
}
[*] --> Feeding : initializeAndSubscribe()
state Resetting {
}
Feeding --> Resetting : RESET
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-watchdog.png">

**** SerialCommandInterface

#+BEGIN_SRC plantuml :file ./documentation/images/state-diagram-serial-command-interface.png :results none
@startuml
!theme spacelab
skinparam backgroundColor #808080
state Inactive {
}
[*] --> Inactive : initializeAndSubscribe()
state Active {
  Active : entry / armSerialTimerLowSpeed()
  Active : exit / disarmSerialTimer()
  Active : on SERIAL_TIMEOUT / pollSerial()
  state Uninitialized {
    Uninitialized : entry / initializeSerial()
  }
  [*] --> Uninitialized
  state WaitingForNewCommand {
    state PlayingPattern {
      PlayingPattern : on COMMAND_PROCESSED / writeBinaryResponse()
      PlayingPattern : on PATTERN_FINISHED_PLAYING / writePatternFinishedResponse()
      PlayingPattern : on PLAY_PATTERN_ERROR / writePatternErrorResponse()
    }
  }
  Uninitialized --> WaitingForNewCommand : SERIAL_INITIALIZED
  state Waiting {
  }
  WaitingForNewCommand --> Waiting : ETHERNET_COMMAND_AVAILABLE
  Waiting --> WaitingForNewCommand : COMMAND_PROCESSED
  state ChoosingCommandProcessor {
  }
  WaitingForNewCommand --> ChoosingCommandProcessor : SERIAL_COMMAND_AVAILABLE
  state ProcessingBinaryCommand {
    ProcessingBinaryCommand : entry / processBinaryCommand()
  }
  ChoosingCommandProcessor --> ProcessingBinaryCommand : PROCESS_BINARY_COMMAND
  ProcessingBinaryCommand --> PlayingPattern : PLAY_PATTERN /\nstorePlayPatternParameters()
  ProcessingBinaryCommand --> PlayingPattern : ANALOG_CLOSED_LOOP /\nstoreAnalogClosedLoopParameters()
  ProcessingBinaryCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
  state ProcessingStreamCommand {
    ProcessingStreamCommand : entry / armSerialTimerHighSpeed()
    ProcessingStreamCommand : exit / armSerialTimerLowSpeed()
    state c <<choice>>
    ProcessingStreamCommand --> c : SERIAL_COMMAND_AVAILABLE /\nupdateStreamCommand()
    state MidStreamCommand {
    }
    c --> MidStreamCommand : [ifStreamCommandComplete()] /\nprocessStreamCommand()
    c --> MidStreamCommand : [else]
  }
  ChoosingCommandProcessor --> ProcessingStreamCommand : PROCESS_STREAM_COMMAND
  ProcessingStreamCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
}
Inactive --> Active : ACTIVATE_SERIAL_COMMAND_INTERFACE
Active --> Inactive : DEACTIVATE_SERIAL_COMMAND_INTERFACE
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-serial-command-interface.png">

**** EthernetCommandInterface

#+BEGIN_SRC plantuml :file ./documentation/images/state-diagram-ethernet-command-interface.png :results none
@startuml
!theme spacelab
skinparam backgroundColor #808080
state Inactive {
}
[*] --> Inactive : initializeAndSubscribe()
state Active {
  Active : entry / armEthernetTimerLowSpeed()
  Active : exit / disarmEthernetTimer()
  Active : on ETHERNET_TIMEOUT / pollEthernet()
  state Uninitialized {
    Uninitialized : on ETHERNET_TIMEOUT / initializeEthernet()
  }
  [*] --> Uninitialized
  state CreatingServerConnection {
    CreatingServerConnection : on ETHERNET_TIMEOUT / createServerConnection()
  }
  Uninitialized --> CreatingServerConnection : ETHERNET_INITIALIZED
  state WaitingForNewCommand {
    state PlayingPattern {
      PlayingPattern : on COMMAND_PROCESSED / writeBinaryResponse()
      PlayingPattern : on PATTERN_FINISHED_PLAYING / writePatternFinishedResponse()
      PlayingPattern : on PLAY_PATTERN_ERROR / writePatternErrorResponse()
    }
  }
  CreatingServerConnection --> WaitingForNewCommand : ETHERNET_SERVER_CONNECTED
  state Waiting {
  }
  WaitingForNewCommand --> Waiting : SERIAL_COMMAND_AVAILABLE
  Waiting --> WaitingForNewCommand : COMMAND_PROCESSED
  state ChoosingCommandProcessor {
  }
  WaitingForNewCommand --> ChoosingCommandProcessor : ETHERNET_COMMAND_AVAILABLE /\nanalyzeCommand()
  state ProcessingBinaryCommand {
    ProcessingBinaryCommand : entry / processBinaryCommand()
  }
  ChoosingCommandProcessor --> ProcessingBinaryCommand : PROCESS_BINARY_COMMAND
  ProcessingBinaryCommand --> PlayingPattern : PLAY_PATTERN /\nstorePlayPatternParameters()
  ProcessingBinaryCommand --> PlayingPattern : ANALOG_CLOSED_LOOP /\nstoreAnalogClosedLoopParameters()
  ProcessingBinaryCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
  state ProcessingStreamCommand {
    ProcessingStreamCommand : entry / armEthernetTimerHighSpeed()
    ProcessingStreamCommand : exit / armEthernetTimerLowSpeed()
    state c <<choice>>
    ProcessingStreamCommand --> c : ETHERNET_COMMAND_AVAILABLE /\nupdateStreamCommand()
    state MidStreamCommand {
    }
    c --> MidStreamCommand : [ifStreamCommandComplete()] /\nprocessStreamCommand()
    c --> MidStreamCommand : [else]
  }
  ChoosingCommandProcessor --> ProcessingStreamCommand : PROCESS_STREAM_COMMAND
  ProcessingStreamCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
}
Inactive --> Active : ACTIVATE_ETHERNET_COMMAND_INTERFACE
Active --> Inactive : DEACTIVATE_ETHERNET_COMMAND_INTERFACE
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-ethernet-command-interface.png">

**** Pattern

#+html: <img src="./documentation/images/state-diagram-pattern.png">

**** Card

#+html: <img src="./documentation/images/state-diagram-card.png">

**** Arena

#+html: <img src="./documentation/images/state-diagram-arena.png">

**** AnalogOutput

#+html: <img src="./documentation/images/state-diagram-analog-output.png">

**** AnalogInput

#+html: <img src="./documentation/images/state-diagram-analog-input.png">

**** Display

#+html: <img src="./documentation/images/state-diagram-display.png">

**** Frame

#+html: <img src="./documentation/images/state-diagram-frame.png">


** Command Set


* Development

** Download this repository

[[https://github.com/janelia-arduino/ArenaController.git]]

#+BEGIN_SRC sh
sudo apt install -y git
mkdir -p ~/tmp && cd ~/tmp && git clone https://github.com/janelia-arduino/ArenaController.git
#+END_SRC

** PlatformIO

*** Install PlatformIO Core

[[https://docs.platformio.org/en/latest/core/installation/index.html]]

**** Example

#+BEGIN_SRC sh
python3 -m venv .venv
source .venv/bin/activate
pip install pip --upgrade
pip install platformio
pio --version
#+END_SRC

**** 99-platformio-udev.rules

Linux users have to install udev rules for PlatformIO supported boards/devices.

***** Download udev rules file to /etc/udev/rules.d

#+BEGIN_SRC sh
curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core/develop/platformio/assets/system/99-platformio-udev.rules | sudo tee /etc/udev/rules.d/99-platformio-udev.rules
#+END_SRC

***** Restart udev management tool

#+BEGIN_SRC sh
sudo service udev restart
#+END_SRC

***** Add user to groups

#+BEGIN_SRC sh
sudo usermod -a -G dialout $USER
sudo usermod -a -G plugdev $USER
#+END_SRC

***** Remove modemmanager

#+BEGIN_SRC sh
sudo apt-get purge --auto-remove modemmanager
#+END_SRC

*** Compile the firmware

#+BEGIN_SRC sh
make teensy-firmware
#+END_SRC

*** Upload the firmware

#+BEGIN_SRC sh
make teensy-upload
#+END_SRC

*** Monitor

#+BEGIN_SRC sh
make monitor
#+END_SRC
