#+EXPORT_FILE_NAME: ../README.md
#+OPTIONS: toc:1 |:t ^:nil tags:nil

# Place warning at the top of the exported file
#+BEGIN_EXAMPLE
<!-- This file is generated automatically from metadata -->
<!-- File edits may be overwritten! -->
#+END_EXAMPLE

* Project Specific Variables                                       :noexport:

#+NAME: library-name
#+BEGIN_SRC text :exports none :noweb yes
ArenaController
#+END_SRC

#+NAME: repository-name
#+BEGIN_SRC text :exports none :noweb yes
ArenaController
#+END_SRC

#+NAME: library-version
#+BEGIN_SRC text :exports none :noweb yes
5.0.2
#+END_SRC

#+NAME: panel-version
#+BEGIN_SRC text :exports none :noweb yes
G4 v1.9
#+END_SRC

#+NAME: description
#+BEGIN_SRC text :exports none :noweb yes
Arduino library for communicating with the Reiser Lab Modular LED panels display arena.
#+END_SRC

#+NAME: references
#+BEGIN_SRC text :exports none :noweb yes
https://github.com/janelia-python/arena_interface_python
https://reiserlab.github.io/Modular-LED-Display/
https://github.com/floesche/LED-Display_G4_Hardware_Arena
https://github.com/leburnett/G4_Display_Tools
https://www.pjrc.com/store/teensy41.html
https://www.pjrc.com/store/ethernet_kit.html
https://github.com/QuantumLeaps/qp-arduino
https://mongoose.ws/
https://www.adafruit.com/product/4470
https://www.adafruit.com/product/1083
#+END_SRC

#+NAME: creation-date
#+BEGIN_SRC text :exports none :noweb yes
2023-08-16
#+END_SRC

* General and Derived Variables                                    :noexport:

#+NAME: release-month-day
#+BEGIN_SRC emacs-lisp :exports none :noweb yes
(format-time-string "%m-%d")
#+END_SRC

#+NAME: release-year
#+BEGIN_SRC emacs-lisp :exports none :noweb yes
(format-time-string "%Y")
#+END_SRC

#+NAME: release-date
#+BEGIN_SRC text :exports none :noweb yes
<<release-year()>>-<<release-month-day()>>
#+END_SRC

#+NAME: license
#+BEGIN_SRC text :exports none :noweb yes
GPL-3.0
#+END_SRC

#+NAME: guix-license
#+BEGIN_SRC text :exports none :noweb yes
license:gpl3+
#+END_SRC

#+NAME: license-files
#+BEGIN_SRC text :exports none :noweb yes
LICENSE
#+END_SRC

#+NAME: repository-organization
#+BEGIN_SRC text :exports none :noweb yes
janelia-arduino
#+END_SRC

#+NAME: forge
#+BEGIN_SRC text :exports none :noweb yes
github.com
#+END_SRC

#+NAME: repository-url
#+BEGIN_SRC text :exports none :noweb yes
https://<<forge>>/<<repository-organization>>/<<repository-name>>
#+END_SRC

#+NAME: git-clone-url-ssh
#+BEGIN_SRC text :exports none :noweb yes
git@<<forge>>:<<repository-organization>>/<<repository-name>>.git
#+END_SRC

#+NAME: author-given-name
#+BEGIN_SRC text :exports none :noweb yes
Peter
#+END_SRC

#+NAME: author-family-name
#+BEGIN_SRC text :exports none :noweb yes
Polidoro
#+END_SRC

#+NAME: author
#+BEGIN_SRC text :exports none :noweb yes
<<author-given-name>> <<author-family-name>>
#+END_SRC

#+NAME: author-email
#+BEGIN_SRC text :exports none :noweb yes
peter@polidoro.io
#+END_SRC

#+NAME: maintainer-given-name
#+BEGIN_SRC text :exports none :noweb yes
Peter
#+END_SRC

#+NAME: maintainer-family-name
#+BEGIN_SRC text :exports none :noweb yes
Polidoro
#+END_SRC

#+NAME: maintainer
#+BEGIN_SRC text :exports none :noweb yes
<<maintainer-given-name>> <<maintainer-family-name>>
#+END_SRC

#+NAME: maintainer-email
#+BEGIN_SRC text :exports none :noweb yes
peter@polidoro.io
#+END_SRC

#+NAME: affiliation
#+BEGIN_SRC text :exports none :noweb yes
Howard Hughes Medical Institute
#+END_SRC

#+NAME: copyright
#+BEGIN_SRC text :exports none :noweb yes
<<release-year()>> <<affiliation>>
#+END_SRC

#+NAME: programming-language
#+BEGIN_SRC text :exports none :noweb yes
c++
#+END_SRC

#+NAME: metadata-dir
#+BEGIN_SRC text :exports none :noweb yes
.metadata
#+END_SRC

#+NAME: documentation-dir
#+BEGIN_SRC text :exports none :noweb yes
documentation
#+END_SRC

#+NAME: images-dir
#+BEGIN_SRC text :exports none :noweb yes
<<documentation-dir>>/images
#+END_SRC

#+name: org-hello
#+begin_src org :var addressee=""
Hello $addressee
#+end_src

#+name: print-org
#+begin_src elisp :var x=org-hello[](addressee="World!")
  (print x)
#+end_src

#+name: repository-info
#+BEGIN_SRC org :noweb yes
- Library Name: <<library-name>>
- Description: <<description>>
- Version: <<library-version>>
- Panel Version: <<panel-version>>
- Release Date: <<release-date>>
- Creation Date: <<creation-date>>
- License: <<license>>
- URL: <<repository-url>>
- Author: <<author>>
- Author Email: <<author-email>>
- Maintainer: <<maintainer>>
- Maintainer Email: <<maintainer-email>>
- Copyright: <<copyright>>
- References:
  - <<references>>
#+END_SRC

* Repository Information

#+call: print-org(x=repository-info[:results raw]()):results raw

* Modular LED Display

#+html: <img src="./documentation/images/arena.png" width="1200px">

Abstract from https://doi.org/10.1101/2022.08.02.502550 :

"Visual stimulation of animals in the laboratory is a powerful technique for
studying sensory control of complex behaviors.

Since commercial displays are optimized for human vision, we established a novel
display system based on custom-built modular LED panels that provides
millisecond refresh, precise synchronization, customizable color combinations,
and varied display configurations.

This system simplifies challenging experiments.

With variants of this display, we probed the speed limits of motion vision and
examined the role of color vision in behavioral experiments with tethered flying
Drosophila.

Using 2-photon calcium imaging, we comprehensively mapped the tuning of visual
projection neurons across the flyâ€™s field of view.

Finally, using real-time behavior analysis, we developed low-latency interactive
virtual environments and found that flying flies can independently control their
navigation along two dimensions.

This display system uniquely addresses most technical challenges of small animal
vision experiments and is thoroughly documented for replicability."

** System Components

*** Quarter Panel

A quarter panel is a set of LED pixels arranged in rows and columns.

#+html: <img src="./documentation/images/quarter_panel.png" width="96px">

*** Panel

A panel is a set of quarter panels arranged in rows and columns.

#+html: <img src="./documentation/images/panel.png" width="192px">

*** Region

A region is a set of panels arranged in rows and columns with a common communication interface.

#+html: <img src="./documentation/images/region.png" width="607px">

*** Display

An display is a set of regions arranged in rows and columns.

#+html: <img src="./documentation/images/display.png" width="1214px">

** Display Messages

*** Quarter Panel

**** Pixels

Pixel numbering for each pixel in a quarter panel:

#+html: <img src="./documentation/images/quarter_panel_pixels.png" width="1200px">

**** Grayscale

In grayscale mode, each LED can be one of sixteen brightness levels.

#+html: <img src="./documentation/images/grayscale.png" width="420px">

#+html: <img src="./documentation/images/quarter_panel_grayscale.png" width="1200px">

**** Binary

In binary mode, each LED can be one of two brightness levels, on or off.

#+html: <img src="./documentation/images/binary.png" width="420px">

#+html: <img src="./documentation/images/quarter_panel_binary.png" width="1200px">

*** Panel

**** Quarter Panels in Panel

Quarter panel numbering for each quarter panel in a panel plus pixel numbering for select pixels in a panel:

#+html: <img src="./documentation/images/panel_quarter_panels.png" width="1200px">

*** Region

**** Regions in Display

Region numbering for each region in an display:

#+html: <img src="./documentation/images/display_regions.png" width="1200px">

**** Panels in Region

Panel numbering for each panel in an region:

#+html: <img src="./documentation/images/region_panels.png" width="600px">

*** Display

**** Panels in Display

Panel update order for each panel in an display:

***** Synchronous

#+html: <img src="./documentation/images/display_panels_synchronous.png" width="1200px">

***** Asynchronous

#+html: <img src="./documentation/images/display_panels_asynchronous.png" width="1200px">

** Firmware

*** Active Objects

| name                     | priority | event-queue-count | state-machines                   |
|--------------------------+----------+-------------------+----------------------------------|
| Watchdog                 |        1 |                 2 | Watchdog                         |
| SerialCommandInterface   |        2 |                10 | SerialCommandInterface           |
| EthernetCommandInterface |        3 |                10 | EthernetCommandInterface         |
| Pattern                  |        4 |                20 | Pattern, Card                    |
| Arena                    |        5 |                20 | Arena, AnalogOutput, AnalogInput |
| Display                  |        6 |                20 | Display                          |
| Frame                    |        7 |                20 | Frame                            |

*** State Diagrams

**** Watchdog

#+BEGIN_SRC plantuml :file ../documentation/images/state-diagram-watchdog.png :results none :exports none
@startuml
!theme spacelab
skinparam backgroundColor #9F9F9F
<style>
.nested0 {
  stateBody {
    BackGroundColor #7F7F7F;
  }
}
</style>
state Feeding <<nested0>> {
  Feeding : entry / armWatchdogTimer()
  Feeding : exit / disarmWatchdogTimer()
  state Initialized {
    Initialized : on WATCHDOG_TIMEOUT / feedWatchdog()
  }
  [*] --> Initialized
}
[*] --> Feeding : initializeAndSubscribe()
state Resetting {
}
Feeding --> Resetting : RESET
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-watchdog.png">

**** SerialCommandInterface

#+BEGIN_SRC plantuml :file ../documentation/images/state-diagram-serial-command-interface.png :results none :exports none
@startuml
!theme spacelab
skinparam backgroundColor #9F9F9F
<style>
.nested0 {
  stateBody {
    BackGroundColor #7F7F7F;
  }
}
.nested1 {
  stateBody {
    BackGroundColor #5F5F5F;
  }
}
</style>
state Inactive {
}
[*] --> Inactive : initializeAndSubscribe()
state Active <<nested0>> {
  Active : entry / armSerialTimerLowSpeed()
  Active : exit / disarmSerialTimer()
  Active : on SERIAL_TIMEOUT / pollSerial()
  state Uninitialized {
    Uninitialized : entry / initializeSerial()
  }
  [*] --> Uninitialized
  state WaitingForNewCommand <<nested1>> {
    state PlayingPattern {
      PlayingPattern : on COMMAND_PROCESSED / writeBinaryResponse()
      PlayingPattern : on PATTERN_FINISHED_PLAYING / writePatternFinishedResponse()
      PlayingPattern : on PLAY_PATTERN_ERROR / writePatternErrorResponse()
    }
  }
  Uninitialized --> WaitingForNewCommand : SERIAL_INITIALIZED
  state Waiting {
  }
  WaitingForNewCommand --> Waiting : ETHERNET_COMMAND_AVAILABLE
  Waiting --> WaitingForNewCommand : COMMAND_PROCESSED
  state ChoosingCommandProcessor {
  }
  WaitingForNewCommand --> ChoosingCommandProcessor : SERIAL_COMMAND_AVAILABLE
  state ProcessingBinaryCommand {
    ProcessingBinaryCommand : entry / processBinaryCommand()
  }
  ChoosingCommandProcessor --> ProcessingBinaryCommand : PROCESS_BINARY_COMMAND
  ProcessingBinaryCommand --> PlayingPattern : PLAY_PATTERN /\nstorePlayPatternParameters()
  ProcessingBinaryCommand --> PlayingPattern : ANALOG_CLOSED_LOOP /\nstoreAnalogClosedLoopParameters()
  ProcessingBinaryCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
  state ProcessingStreamCommand <<nested1>> {
    ProcessingStreamCommand : entry / armSerialTimerHighSpeed()
    ProcessingStreamCommand : exit / armSerialTimerLowSpeed()
    state c <<choice>>
    ProcessingStreamCommand --> c : SERIAL_COMMAND_AVAILABLE /\nupdateStreamCommand()
    state MidStreamCommand {
    }
    c --> MidStreamCommand : [ifStreamCommandComplete()] /\nprocessStreamCommand()
    c --> MidStreamCommand : [else]
  }
  ChoosingCommandProcessor --> ProcessingStreamCommand : PROCESS_STREAM_COMMAND
  ProcessingStreamCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
}
Inactive --> Active : ACTIVATE_SERIAL_COMMAND_INTERFACE
Active --> Inactive : DEACTIVATE_SERIAL_COMMAND_INTERFACE
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-serial-command-interface.png">

**** EthernetCommandInterface

#+BEGIN_SRC plantuml :file ../documentation/images/state-diagram-ethernet-command-interface.png :results none :exports none
@startuml
!theme spacelab
skinparam backgroundColor #9F9F9F
<style>
.nested0 {
  stateBody {
    BackGroundColor #7F7F7F;
  }
}
.nested1 {
  stateBody {
    BackGroundColor #5F5F5F;
  }
}
</style>
state Inactive {
}
[*] --> Inactive : initializeAndSubscribe()
state Active <<nested0>> {
  Active : entry / armEthernetTimerLowSpeed()
  Active : exit / disarmEthernetTimer()
  Active : on ETHERNET_TIMEOUT / pollEthernet()
  state Uninitialized {
    Uninitialized : on ETHERNET_TIMEOUT / initializeEthernet()
  }
  [*] --> Uninitialized
  state CreatingServerConnection {
    CreatingServerConnection : on ETHERNET_TIMEOUT / createServerConnection()
  }
  Uninitialized --> CreatingServerConnection : ETHERNET_INITIALIZED
  state WaitingForNewCommand <<nested1>> {
    state PlayingPattern {
      PlayingPattern : on COMMAND_PROCESSED / writeBinaryResponse()
      PlayingPattern : on PATTERN_FINISHED_PLAYING / writePatternFinishedResponse()
      PlayingPattern : on PLAY_PATTERN_ERROR / writePatternErrorResponse()
    }
  }
  CreatingServerConnection --> WaitingForNewCommand : ETHERNET_SERVER_CONNECTED
  state Waiting {
  }
  WaitingForNewCommand --> Waiting : SERIAL_COMMAND_AVAILABLE
  Waiting --> WaitingForNewCommand : COMMAND_PROCESSED
  state ChoosingCommandProcessor {
  }
  WaitingForNewCommand --> ChoosingCommandProcessor : ETHERNET_COMMAND_AVAILABLE /\nanalyzeCommand()
  state ProcessingBinaryCommand {
    ProcessingBinaryCommand : entry / processBinaryCommand()
  }
  ChoosingCommandProcessor --> ProcessingBinaryCommand : PROCESS_BINARY_COMMAND
  ProcessingBinaryCommand --> PlayingPattern : PLAY_PATTERN /\nstorePlayPatternParameters()
  ProcessingBinaryCommand --> PlayingPattern : ANALOG_CLOSED_LOOP /\nstoreAnalogClosedLoopParameters()
  ProcessingBinaryCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
  state ProcessingStreamCommand <<nested1>> {
    ProcessingStreamCommand : entry / armEthernetTimerHighSpeed()
    ProcessingStreamCommand : exit / armEthernetTimerLowSpeed()
    state c <<choice>>
    ProcessingStreamCommand --> c : ETHERNET_COMMAND_AVAILABLE /\nupdateStreamCommand()
    state MidStreamCommand {
    }
    c --> MidStreamCommand : [ifStreamCommandComplete()] /\nprocessStreamCommand()
    c --> MidStreamCommand : [else]
  }
  ChoosingCommandProcessor --> ProcessingStreamCommand : PROCESS_STREAM_COMMAND
  ProcessingStreamCommand --> WaitingForNewCommand : COMMAND_PROCESSED /\nwriteBinaryResponse()
}
Inactive --> Active : ACTIVATE_ETHERNET_COMMAND_INTERFACE
Active --> Inactive : DEACTIVATE_ETHERNET_COMMAND_INTERFACE
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-ethernet-command-interface.png">

**** Pattern

#+BEGIN_SRC plantuml :file ../documentation/images/state-diagram-pattern.png :results none :exports none
@startuml
!theme spacelab
skinparam backgroundColor #9F9F9F
<style>
.nested0 {
  stateBody {
    BackGroundColor #7F7F7F;
  }
}
.nested1 {
  stateBody {
    BackGroundColor #5F5F5F;
  }
}
.nested2 {
  stateBody {
    BackGroundColor #3F3F3F;
  }
}
</style>
state Initialized <<nested0>> {
  Initialized : on PLAY_PATTERN / initializePlayPattern()
  Initialized : on SHOW_PATTERN_FRAME / initializeShowPatternFrame()
  Initialized : on FIND_PATTERN / dispatchToCard()
  Initialized : on FIND_CARD / dispatchToCard()
  Initialized : on CARD_FOUND / dispatchToCard()
  Initialized : on DIRECTORY_OPEN_SUCCESS / dispatchToCard()
  Initialized : on DIRECTORY_OPEN_FAILURE / dispatchToCard()
  Initialized : on ANALOG_CLOSED_LOOP / initializeAnalogClosedLoop()
  Initialized : on FILENAME_SORT_FAILURE / dispatchToCard()
  Initialized : on FILE_VALID / dispatchToCard()
  Initialized : on FILE_NOT_VALID / handleErrorAndDispatchToCard()
  Initialized : on PATTERN_NOT_VALID / handleErrorAndDispatchToCard()
  Initialized : on SET_FRAME_COUNT_PER_PATTERN / setFrameCountPerPattern()
  Initialized : on SET_BYTE_COUNT_PER_FRAME / setByteCountPerFrame()
  state Inactive {
    Inactive : exit / armFindCardTimer()
  }
  [*] --> Inactive
  state AnalyzingCard {
  }
  Inactive --> AnalyzingCard : BEGIN_PLAYING_PATTERN /\ndeferBeginPattern()
  Inactive --> AnalyzingCard : BEGIN_SHOWING_PATTERN_FRAME /\ndeferBeginPattern()
  AnalyzingCard --> Inactive : CARD_NOT_FOUND /\nhandleErrorAndDispatchToCard()
  state CardAnalyzed {
    CardAnalyzed : entry / recallBeginPattern()
    CardAnalyzed : exit / dispatchFindPatternToCard()
  }
  AnalyzingCard --> CardAnalyzed : FILENAME_SORT_SUCCESS /\ndispatchToCard()
  state DisplayingPattern <<nested1>> {
    state WaitingToPlayPattern {
    }
    state PlayingPattern <<nested2>> {
      PlayingPattern : entry / armTimers()
      PlayingPattern : exit / disarmTimersAndCleanup()
      PlayingPattern : on FRAME_RATE_TIMEOUT / deferFrameRate()
      PlayingPattern : on RUNTIME_DURATION_TIMEOUT / endRuntimeDuration()
      PlayingPattern : on GOT_ANALOG_INPUT / updateAnalogClosedLoopValues()
      state PP_ReadingFrameFromFile {
        PP_ReadingFrameFromFile : entry / readFrameFromFile()
      }
      [*] --> PP_ReadingFrameFromFile : / initializeFrameIndex()
      state WaitingToDisplayFrame {
        WaitingToDisplayFrame : entry / recallFrameRate()
      }
      PP_ReadingFrameFromFile --> WaitingToDisplayFrame : FRAME_READ_FROM_FILE /\nsaveFrameReference()
      state PP_DecodingFrame {
        PP_DecodingFrame : entry / decodeFrame()
      }
      WaitingToDisplayFrame --> PP_DecodingFrame : FRAME_RATE_TIMEOUT /\ndeactivateDisplay()
      state PP_FillingFrameBufferWithDecodedFrame {
        PP_FillingFrameBufferWithDecodedFrame : entry / fillFrameBufferWithDecodedFrame()
      }
      PP_DecodingFrame --> PP_FillingFrameBufferWithDecodedFrame : FRAME_DECODED
      state PP_DisplayingFrame {
        PP_DisplayingFrame : entry / displayFrame()
      }
      PP_FillingFrameBufferWithDecodedFrame --> PP_DisplayingFrame : FRAME_FILLED
      PP_DisplayingFrame --> PP_ReadingFrameFromFile : FRAME_TRANSFERRED /\nsetupNextFrame()
    }
    WaitingToPlayPattern --> PlayingPattern : PATTERN_VALID /\nsetGrayscaleAndDispatchToCard()
    state WaitingToShowPatternFrame {
    }
    state ShowingPatternFrame <<nested2>> {
      ShowingPatternFrame : exit / deleteFrameReference()
      state SPF_ReadingFrameFromFile {
        SPF_ReadingFrameFromFile : entry / readFrameFromFile()
      }
      [*] --> SPF_ReadingFrameFromFile : / deactivateDisplay()
      state SPF_DecodingFrame {
        SPF_DecodingFrame : entry / decodeFrame()
      }
      SPF_ReadingFrameFromFile --> SPF_DecodingFrame : FRAME_READ_FROM_FILE /\nsaveFrameReference()
      state SPF_FillingFrameBufferWithDecodedFrame {
        SPF_FillingFrameBufferWithDecodedFrame : entry / fillFrameBufferWithDecodedFrame()
      }
      SPF_DecodingFrame --> SPF_FillingFrameBufferWithDecodedFrame : FRAME_DECODED
      state SPF_DisplayingFrame {
        SPF_DisplayingFrame : entry / displayFrame()
      }
      SPF_FillingFrameBufferWithDecodedFrame --> SPF_DisplayingFrame : FRAME_FILLLED
      state WaitingToDisplayNextFrame {
      }
      SPF_DisplayingFrame --> WaitingToDisplayNextFrame : FRAME_TRANSFERRED
      WaitingToDisplayNextFrame --> SPF_ReadingFrameFromFile : UPDATE_PATTERN_FRAME /\nupdatePatternFrame()
    }
    WaitingToShowPatternFrame --> ShowingPatternFrame : PATTERN_VALID /\nsetGrayscaleAndDispatchToCard()
  }
  CardAnalyzed --> WaitingToPlayPattern : BEGIN_PLAYING_PATTERN
  CardAnalyzed --> WaitingToShowPatternFrame : BEGIN_SHOWING_PATTERN_FRAME
  DisplayingPattern --> CardAnalyzed : END_PLAYING_PATTERN /\ndispatchToCard()
  DisplayingPattern --> CardAnalyzed : END_SHOWING_PATTERN_FRAME /\ndispatchToCard()
}
[*] --> Initialized : initializeAndSubscribe()
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-pattern.png">

**** Card

#+BEGIN_SRC plantuml :file ../documentation/images/state-diagram-card.png :results none :exports none
@startuml
!theme spacelab
skinparam backgroundColor #9F9F9F
<style>
.nested0 {
  stateBody {
    BackGroundColor #7F7F7F;
  }
}
.nested1 {
  stateBody {
    BackGroundColor #5F5F5F;
  }
}
.nested2 {
  stateBody {
    BackGroundColor #3F3F3F;
  }
}
</style>
state Initialized <<nested0>> {
  Initialized : on PLAY_PATTERN / storePlayPatternParameters()
  Initialized : on SHOW_PATTERN_FRAME / storeShowPatternParameters()
  Initialized : on ANALOG_CLOSED_LOOP / storeAnalogClosedLoopParameters()
  state WaitingToFindCard {
  }
  [*] --> WaitingToFindCard
  state FindingCard {
    FindingCard : entry / findCard()
  }
  WaitingToFindCard --> FindingCard : FIND_CARD
  FindingCard --> WaitingToFindCard : CARD_NOT_FOUND /\npostAllOff()
  state OpeningDirectory {
    OpeningDirectory : entry / openDirectory()
  }
  FindingCard --> OpeningDirectory : CARD_FOUND
  OpeningDirectory --> FindingCard : DIRECTORY_OPEN_FAILURE
}
[*] --> Initialized : initialize()
@enduml
#+END_SRC

#+html: <img src="./documentation/images/state-diagram-card.png">

**** Arena

#+html: <img src="./documentation/images/state-diagram-arena.png">

**** AnalogOutput

#+html: <img src="./documentation/images/state-diagram-analog-output.png">

**** AnalogInput

#+html: <img src="./documentation/images/state-diagram-analog-input.png">

**** Display

#+html: <img src="./documentation/images/state-diagram-display.png">

**** Frame

#+html: <img src="./documentation/images/state-diagram-frame.png">


** Command Set

* Development

** Download this repository

[[https://github.com/janelia-arduino/ArenaController.git]]

#+BEGIN_SRC sh
sudo apt install -y git
mkdir -p ~/tmp && cd ~/tmp && git clone https://github.com/janelia-arduino/ArenaController.git
#+END_SRC

** PlatformIO

*** Install PlatformIO Core

[[https://docs.platformio.org/en/latest/core/installation/index.html]]

**** Example

#+BEGIN_SRC sh
python3 -m venv .venv
source .venv/bin/activate
pip install pip --upgrade
pip install platformio
pio --version
#+END_SRC

**** 99-platformio-udev.rules

Linux users have to install udev rules for PlatformIO supported boards/devices.

***** Download udev rules file to /etc/udev/rules.d

#+BEGIN_SRC sh
curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core/develop/platformio/assets/system/99-platformio-udev.rules | sudo tee /etc/udev/rules.d/99-platformio-udev.rules
#+END_SRC

***** Restart udev management tool

#+BEGIN_SRC sh
sudo service udev restart
#+END_SRC

***** Add user to groups

#+BEGIN_SRC sh
sudo usermod -a -G dialout $USER
sudo usermod -a -G plugdev $USER
#+END_SRC

***** Remove modemmanager

#+BEGIN_SRC sh
sudo apt-get purge --auto-remove modemmanager
#+END_SRC

*** Compile the firmware

#+BEGIN_SRC sh
make teensy-firmware
#+END_SRC

*** Upload the firmware

#+BEGIN_SRC sh
make teensy-upload
#+END_SRC

*** Monitor

#+BEGIN_SRC sh
make monitor
#+END_SRC

* Tangled Files                                                    :noexport:

#+BEGIN_SRC text :tangle ../library.properties :exports none :noweb yes
# This file is generated automatically from .metadata.org
# File edits may be overwritten!
name=<<library-name>>
version=<<library-version>>
author=<<author>> <<author-email>>
maintainer=<<maintainer>> <<maintainer-email>>
sentence=<<description>>
paragraph=Like this project? Please star it on GitHub!
category=Device Control
url=<<repository-url>>
architectures=*
#+END_SRC
